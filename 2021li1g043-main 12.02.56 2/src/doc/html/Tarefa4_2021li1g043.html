<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Tarefa4_2021li1g043</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>Jo&#227;o Magalh&#227;es &lt;a100740@alunos.uminho.pt&gt;;<br />: Gon&#231;alo Loureiro &lt;a100535@alunos.uminho.pt&gt;;</td></tr><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr></table><p class="caption">Tarefa4_2021li1g043</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>M&#243;dulo para a realiza&#231;&#227;o da Tarefa 4 do projeto de LI1 em 2021/22.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:correrMovimentos">correrMovimentos</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; [<a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a>] -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a></li><li class="src short"><a href="#v:moveJogador">moveJogador</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a></li><li class="src short"><a href="#v:podeAndar">podeAndar</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; Bool</li><li class="src short"><a href="#v:andaCaixa">andaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:andaCaixaAux">andaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:largaCaixa">largaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:largaCaixaAux">largaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:pegaCaixa">pegaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:pegaCaixaAux">pegaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a></li><li class="src short"><a href="#v:andaJogador">andaJogador</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a></li><li class="src short"><a href="#v:yDoChao">yDoChao</a> :: <a href="LI12122.html#t:Coordenadas" title="LI12122">Coordenadas</a> -&gt; [(<a href="LI12122.html#t:Peca" title="LI12122">Peca</a>, <a href="LI12122.html#t:Coordenadas" title="LI12122">Coordenadas</a>)] -&gt; Int</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a id="v:correrMovimentos" class="def">correrMovimentos</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; [<a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a>] -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> <a href="#v:correrMovimentos" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o geral</h2><p>Aplicamos a fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> dando-lhe um jogo e uma lista de movimentos para assim conseguirmos mexer o jogador no mapa.</p><p>Para que consigamos fazer isso vamos utilizar a fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:moveJogador" title="Tarefa4_2021li1g043">moveJogador</a></code>.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o tem como caso de paragem a lista vazia de movimentos, [].</p><pre>correrMovimentos :: Jogo -&gt; [Movimento] -&gt; Jogo
correrMovimentos jogo []      = jogo
correrMovimentos jogo (mov:t) = correrMovimentos (moveJogador jogo mov)
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>correrMovimentos (Jogo [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste False)) [InterageCaixa, AndarEsquerda] = (Jogo [[Vazio, Vazio, Caixa, Vazio], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (2,1) Oeste True))
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:moveJogador" class="def">moveJogador</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> <a href="#v:moveJogador" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Aplicamos a fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:moveJogador" title="Tarefa4_2021li1g043">moveJogador</a></code> para conseguirmos movimentar o jogador a partir de 4 movimentos poss&#237;veis, fazendo-o assim mover-se no mapa.</p><p>Para que consigamos fazer isso vamos utilizar as fun&#231;&#245;es <code><a href="Tarefa4_2021li1g043.html#v:podeAndar" title="Tarefa4_2021li1g043">podeAndar</a></code>, <code><a href="Tarefa4_2021li1g043.html#v:andaCaixa" title="Tarefa4_2021li1g043">andaCaixa</a></code>, <code><a href="Tarefa4_2021li1g043.html#v:andaJogador" title="Tarefa4_2021li1g043">andaJogador</a></code>, <code><a href="Tarefa4_2021li1g043.html#v:largaCaixa" title="Tarefa4_2021li1g043">largaCaixa</a></code>, <code><a href="Tarefa4_2021li1g043.html#v:pegaCaixa" title="Tarefa4_2021li1g043">pegaCaixa</a></code></p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><p><code>
moveJogador :: Jogo -&gt; Movimento -&gt; Jogo
moveJogador j</code>(Jogo mapa (Jogador (x,y) dir bool)) mov
                                                | mov == AndarDireita &amp;&amp; dir == Este &amp;&amp; bool == False &amp;&amp; podeAndar(Jogo mapa (Jogador (x,y) Este False)) AndarDireita = andaJogador j AndarDireita  --^ Andar sem caixa para o lado Direito.
                                                | mov == AndarDireita &amp;&amp; dir == Este &amp;&amp; bool == True  &amp;&amp; podeAndar(Jogo mapa (Jogador (x,y) Este True)) AndarDireita  = andaJogador j AndarDireita  --^ Andar com caixa para o lado Direito.
                                                | mov == AndarEsquerda &amp;&amp; dir == Oeste &amp;&amp; bool == False &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Oeste False)) AndarEsquerda = andaJogador j AndarEsquerda  --^ Andar sem caixa para o lado Esquerdo.                                         
                                                | mov == AndarEsquerda &amp;&amp; dir == Oeste &amp;&amp; bool == True  &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Oeste True)) AndarEsquerda  = andaJogador j AndarEsquerda  --^ Andar com caixa para o lado Esquerdo.                                                                         
                                                | mov == Trepar &amp;&amp; dir == Este  &amp;&amp; bool == False &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Este  False)) Trepar = (Jogo mapa (Jogador (x+1,y-1) Este  False)) --^ Subir sem caixa para o lado Direito.
                                                | mov == Trepar &amp;&amp; dir == Oeste &amp;&amp; bool == False &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Oeste False)) Trepar = (Jogo mapa (Jogador (x-1,y-1) Oeste False)) --^ Subir sem caixa para o lado Esquerdo.                              
                                                | mov == Trepar &amp;&amp; dir == Este  &amp;&amp; bool == True &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Este  True)) Trepar = (Jogo (andaCaixa j Trepar) (Jogador (x+1,y-1) Este  True)) --^ Subir com caixa para o lado Direito.
                                                | mov == Trepar &amp;&amp; dir == Oeste &amp;&amp; bool == True &amp;&amp; podeAndar (Jogo mapa (Jogador (x,y) Oeste True)) Trepar = (Jogo (andaCaixa j Trepar) (Jogador (x-1,y-1) Oeste True)) --^ Subir com caixa para o lado Esquerdo. 
                                                | mov == InterageCaixa &amp;&amp; dir == Este  &amp;&amp; bool == True &amp;&amp; (elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; not(elem(Porta,(x+1,y)) (constroiMapaPVO(desconstroiMapa mapa))) = (Jogo (largaCaixa (Jogo (constroiMapa(desconstroiMapa mapa)) (Jogador (x,y) Este True)))  (Jogador (x,y) Este  False)) --^ Largar a caixa para o lado Esquerdo.
                                                | mov == InterageCaixa &amp;&amp; dir == Oeste &amp;&amp; bool == True &amp;&amp; (elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; not(elem(Porta,(x-1,y)) (constroiMapaPVO(desconstroiMapa mapa))) = (Jogo (largaCaixa (Jogo (constroiMapa(desconstroiMapa mapa)) (Jogador (x,y) Oeste True))) (Jogador (x,y) Oeste False)) --^ Largar a caixa para o lado Direito.
                                                | mov == InterageCaixa &amp;&amp; dir == Este  &amp;&amp; bool == False &amp;&amp; (elem(Caixa,(x+1,y)) (desconstroiMapa mapa)) &amp;&amp; (elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; (elem(Vazio,(x,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) = (Jogo (pegaCaixa (Jogo (constroiMapa(desconstroiMapa mapa)) (Jogador (x,y) Este  False))) (Jogador (x,y) Este  True)) --^ Pegar a caixa quando esta se encontra do lado Esquerdo.
                                                | mov == InterageCaixa &amp;&amp; dir == Oeste &amp;&amp; bool == False &amp;&amp; (elem(Caixa,(x-1,y)) (desconstroiMapa mapa)) &amp;&amp; (elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; (elem(Vazio,(x,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) = (Jogo (pegaCaixa (Jogo (constroiMapa(desconstroiMapa mapa)) (Jogador (x,y) Oeste False))) (Jogador (x,y) Oeste True)) --^ Pegar a caixa quando esta se encontra do lado Direito. 
                                                | mov == AndarDireita  &amp;&amp; dir == Oeste = moveJogador (Jogo mapa (Jogador (x,y) Este  bool))  AndarDireita --^ Andar para a Direita quando est&#225; virado para o lado Esquerdo.
                                                | mov == AndarEsquerda &amp;&amp; dir == Este  = moveJogador (Jogo mapa (Jogador (x,y) Oeste bool)) AndarEsquerda --^ Andar para a Esquerdo quando est&#225; virado para o lado Direito.
                                                | otherwise = j --^ Se nenhum dos casos anteriores se verificar, devolve o mesmo jogo.</p><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:moveJogador" title="Tarefa4_2021li1g043">moveJogador</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>moveJogador (Jogo [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste False)) InterageCaixa = (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True))
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:podeAndar" class="def">podeAndar</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; Bool <a href="#v:podeAndar" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Verificar a veracidade do movimento.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Aplicamos a fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:podeAndar" title="Tarefa4_2021li1g043">podeAndar</a></code> para verificar se o movimento do jogador &#233; poss&#237;vel de ser executado, devolvendo True no caso de o ser. Caso contr&#225;rio, False.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><p>podeAndar :: Jogo -&gt; Movimento -&gt; Bool
podeAndar j@(Jogo mapa (Jogador (x,y) dir bool)) mov
                                   | mov == AndarDireita  &amp;&amp; dir == Este  &amp;&amp; bool == False &amp;&amp; ((elem(Vazio,(x+1,y)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x+1,y)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Bloco,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Caixa,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Vazio,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))))  = True --^ Andar sem caixa para a Direita.
                                   | mov == AndarEsquerda &amp;&amp; dir == Oeste &amp;&amp; bool == False &amp;&amp; ((elem(Vazio,(x-1,y)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x-1,y)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Bloco,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Caixa,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Vazio,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))))  = True --^ Andar sem caixa para a Esquerda.                                                                                                  
                                   | mov == AndarDireita  &amp;&amp; dir == Este  &amp;&amp; bool == True &amp;&amp; ((elem(Vazio,(x+1,y)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; (elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Bloco,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Caixa,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Vazio,(x+1,y+1)) (constroiMapaPVO(desconstroiMapa mapa)))) = True --^ Andar com caixa para a Direita.
                                   | mov == AndarEsquerda &amp;&amp; dir == Oeste &amp;&amp; bool == True &amp;&amp; ((elem(Vazio,(x-1,y)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; (elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Bloco,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Caixa,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Vazio,(x-1,y+1)) (constroiMapaPVO(desconstroiMapa mapa)))) = True --^ Andar com caixa para a Esquerda.                               
                                   | mov == Trepar &amp;&amp; dir == Este  &amp;&amp; bool == False &amp;&amp; (elem(Vazio,(x,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Caixa,(x+1,y)) (desconstroiMapa mapa)) || (elem(Bloco,(x+1,y)) (desconstroiMapa mapa))) = True --^ Trepar sem caixa para a Direita. 
                                   | mov == Trepar &amp;&amp; dir == Oeste &amp;&amp; bool == False &amp;&amp; (elem(Vazio,(x,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; ((elem(Caixa,(x-1,y)) (desconstroiMapa mapa)) || (elem(Bloco,(x-1,y)) (desconstroiMapa mapa))) = True --^ Trepar sem caixa para a Esquerda.                                                        
                                   | mov == Trepar &amp;&amp; dir == Este  &amp;&amp; bool == True &amp;&amp; (elem(Vazio,(x,y-2)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; (elem(Vazio,(x+1,y-2)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Caixa,(x+1,y)) (desconstroiMapa mapa)) || (elem(Bloco,(x+1,y)) (desconstroiMapa mapa))) = True --^ Trepar com caixa para a Direita.
                                   | mov == Trepar &amp;&amp; dir == Oeste &amp;&amp; bool == True &amp;&amp; (elem(Vazio,(x,y-2)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa))) || (elem(Porta,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)))) &amp;&amp; (elem(Vazio,(x-1,y-2)) (constroiMapaPVO(desconstroiMapa mapa))) &amp;&amp; ((elem(Caixa,(x-1,y)) (desconstroiMapa mapa)) || (elem(Bloco,(x-1,y)) (desconstroiMapa mapa))) = True --^ Trepar com caixa para a Esquerda.                                          
                                   | otherwise = False</p><h2>Exemplos de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:podeAndar" title="Tarefa4_2021li1g043">podeAndar</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>podeAndar (Jogo [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste False)) AndarEsquerda = False
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>podeAndar (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) AndarEsquerda = True
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:andaCaixa" class="def">andaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:andaCaixa" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Mover a Caixa.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Caixa na posi&#231;&#227;o a cima da que ir&#225; corresponder, futuramente, &#224; do Jogador ap&#243;s o movimento.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>andaCaixa :: Jogo -&gt; Movimento -&gt; Mapa
andaCaixa (Jogo mapa (Jogador (x,y) dir True)) mov
                                        | dir == Este  &amp;&amp; podeAndar j mov = andaCaixaAux( Jogo (constroiMapa(take((xmaximo + 1) * yqE + x + 1) listatoda ++ [(Caixa,(x+1,yqE))] ++ drop ((xmaximo +1)*yqE + x + 2) listatoda)) (Jogador (x,y) dir True ))
                                        | dir == Oeste &amp;&amp; podeAndar j mov = andaCaixaAux( Jogo (constroiMapa(take((xmaximo + 1) * yqO + x - 1) listatoda ++ [(Caixa,(x-1,yqO))] ++ drop ((xmaximo +1)*yqO + x) listatoda)) (Jogador (x,y) dir True ))
                             where xmaximo   = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as. 
                                        listatoda = constroiMapaPVO(desconstroiMapa mapa)
                                        yqE = ((yDoChao (x+1,y) (desconstroiMapa mapa)) - 1) --^ Determina o <code>y</code> respetivo ao jogador depois de se mover para o lado direito. Ao subtrair '-1' obtemos a posi&#231;ao da Caixa.
                                        yqO = ((yDoChao (x-1,y) (desconstroiMapa mapa)) - 1) --^ Determina o <code>y</code> respetivo ao jogador depois de se mover para o lado esquerdo. Ao subtrair '-1' obtemos a posi&#231;ao da Caixa.
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:andaCaixa" title="Tarefa4_2021li1g043">andaCaixa</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>andaCaixa (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) AndarEsquerda = [[Vazio, Vazio, Caixa, Vazio], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre><h2>Defini&#231;&#227;o Geral</h2><p>Auxiliar a fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:andaCaixa" title="Tarefa4_2021li1g043">andaCaixa</a></code>.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Vazio na posi&#231;&#227;o a cima &#224; do Jogador antes do movimento.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:andaCaixa" title="Tarefa4_2021li1g043">andaCaixa</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>andaCaixaAux :: Jogo -&gt; Mapa 
andaCaixaAux (Jogo mapa (Jogador (x,y) dir True)) = constroiMapa(take((xmaximo + 1) * (y-1) + x) listatoda ++ [(Vazio,(x,y-1))] ++ drop ((xmaximo +1)*(y-1) + x + 1) listatoda)  
                          where xmaximo   = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as.
                                listatoda = constroiMapaPVO(desconstroiMapa mapa)
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:andaCaixaAux" title="Tarefa4_2021li1g043">andaCaixaAux</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>andaCaixaAux (Jogo [[Vazio, Vazio, Caixa, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = [[Vazio, Vazio, Caixa, Vazio], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:andaCaixaAux" class="def">andaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:andaCaixaAux" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:largaCaixa" class="def">largaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:largaCaixa" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Larga a Caixa.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Caixa na posi&#231;&#227;o &#224; frente da do Jogador.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>largaCaixa :: Jogo -&gt; Mapa
largaCaixa (Jogo mapa (Jogador (x,y) dir True))
                              | dir == Este  &amp;&amp; elem(Vazio,(x+1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)) = largaCaixaAux(Jogo (constroiMapa(take((xmaximo + 1) * kE  + x + 1) listatoda    ++ [(Caixa,(x+1,kE))]  ++ drop ((xmaximo +1)* kE + x + 2) listatoda))    (Jogador (x,y) Este  False))
                              | dir == Oeste &amp;&amp; elem(Vazio,(x-1,y-1)) (constroiMapaPVO(desconstroiMapa mapa)) = largaCaixaAux(Jogo (constroiMapa(take((xmaximo + 1) * kO  + x - 1) listatoda    ++ [(Caixa,(x-1,kO))]  ++ drop ((xmaximo +1)* kO + x) listatoda))        (Jogador (x,y) Oeste  False))                       
                              | otherwise = mapa
                        where xmaximo = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as.                             
                              listatoda = constroiMapaPVO(desconstroiMapa mapa)
                              kE = yDoChao (x+1,y) (desconstroiMapa mapa) --^ y da caixa quando esta cai para o lado Este
                              kO = yDoChao (x-1,y) (desconstroiMapa mapa) --^ y da caixa quando esta cai para o lado Oeste
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:largaCaixa" title="Tarefa4_2021li1g043">largaCaixa</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>largaCaixa (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre><h2>Defini&#231;&#227;o Geral</h2><p>Auxilia a fun&#231;ao <code><a href="Tarefa4_2021li1g043.html#v:largaCaixa" title="Tarefa4_2021li1g043">largaCaixa</a></code>.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Vazio na posi&#231;&#227;o em cima da do Jogador.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:largaCaixa" title="Tarefa4_2021li1g043">largaCaixa</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>largaCaixaAux :: Jogo -&gt; Mapa
largaCaixaAux (Jogo mapa (Jogador (x,y) dir bool)) = constroiMapa(take((xmaximo + 1) * (y-1) + x) listatoda ++ [(Vazio,(x,y-1))] ++ drop((xmaximo +1)* (y-1) + x + 1) listatoda)
                        where xmaximo = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as.                              
                              listatoda = constroiMapaPVO(desconstroiMapa mapa)
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:largaCaixaAux" title="Tarefa4_2021li1g043">largaCaixaAux</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>largaCaixaAux (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:largaCaixaAux" class="def">largaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:largaCaixaAux" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:pegaCaixa" class="def">pegaCaixa</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:pegaCaixa" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Pegar a Caixa.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Caixa na posi&#231;&#227;o em cima da do Jogador.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>pegaCaixa :: Jogo -&gt; Mapa
pegaCaixa (Jogo mapa (Jogador (x,y) dir bool))
                        | dir == Este  &amp;&amp; bool == False = pegaCaixaAux( Jogo (constroiMapa( take((xmaximo + 1) * y + x ) listatoda ++ [(Vazio,(x+1,y))] ++ drop ((xmaximo +1)* (y-1) + x + 1) listatoda)) (Jogador (x,y) Este True))
                        | dir == Oeste &amp;&amp; bool == False = pegaCaixaAux( Jogo (constroiMapa( take((xmaximo + 1) * y + x - 1) listatoda ++ [(Vazio,(x-1,y))] ++ drop ((xmaximo +1)* (y-1) + x) listatoda)) (Jogador (x,y) Oeste True))                          
                        | otherwise = mapa
                where  xmaximo   = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as.
                       listatoda = constroiMapaPVO(desconstroiMapa mapa
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:pegaCaixa" title="Tarefa4_2021li1g043">pegaCaixa</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pegaCaixa (Jogo [[Vazio, Vazio, Vazio, Vazio], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre><h2>Defini&#231;&#227;o Geral</h2><p>Auxilia a fun&#231;ao <code><a href="Tarefa4_2021li1g043.html#v:pegaCaixa" title="Tarefa4_2021li1g043">pegaCaixa</a></code>.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s da utiliza&#231;&#227;o das fun&#231;&#245;es predefinidas <code>take</code> e <code>drop</code>, atualizamos o mapa colocando a pe&#231;a Vazio na posi&#231;&#227;o &#224; frente da do Jogador.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:pegaCaixa" title="Tarefa4_2021li1g043">pegaCaixa</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>pegaCaixaAux :: Jogo -&gt; Mapa
pegaCaixaAux (Jogo mapa (Jogador (x,y) dir bool))  
                               | dir == Este  = constroiMapa( take((xmaximo + 1) * (y-1) + x) listatoda ++ [(Caixa,(x,y-1))] ++ drop ((xmaximo +1)* (y-1) + x + 1) listatoda)
                               | dir == Oeste = constroiMapa( take((xmaximo + 1) * (y-1) + x) listatoda ++ [(Caixa,(x,y-1))] ++ drop ((xmaximo +1)* (y-1) + x + 1) listatoda)
                      where  xmaximo   = xMax (map snd(desconstroiMapa mapa)) --^ Determina a abcissa m&#225;xima do mapa. Ao somar '+1' obtemos o n&#250;mero m&#225;ximo de Pe&#231;as.
                             listatoda = constroiMapaPVO(desconstroiMapa mapa)
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:pegaCaixaAux" title="Tarefa4_2021li1g043">pegaCaixaAux</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>pegaCaixaAux (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]]
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:pegaCaixaAux" class="def">pegaCaixaAux</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Mapa" title="LI12122">Mapa</a> <a href="#v:pegaCaixaAux" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:andaJogador" class="def">andaJogador</a> :: <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> -&gt; <a href="LI12122.html#t:Movimento" title="LI12122">Movimento</a> -&gt; <a href="LI12122.html#t:Jogo" title="LI12122">Jogo</a> <a href="#v:andaJogador" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Atualizar o Jogo depois de um movimento.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>Atrav&#233;s do auxilio da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:andaCaixa" title="Tarefa4_2021li1g043">andaCaixa</a></code> e da <code>ydoChao</code>, atualizamos o mapa e a respetiva posi&#231;&#227;o do Jogador.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar da <code><a href="Tarefa4_2021li1g043.html#v:correrMovimentos" title="Tarefa4_2021li1g043">correrMovimentos</a></code> logo, o seu caso de paragem est&#225; intr&#237;nseco a esta.</p><pre>andaJogador :: Jogo -&gt; Movimento -&gt; Jogo
andaJogador j@(Jogo mapa (Jogador (x,y) dir bool )) mov
                                 | mov == AndarEsquerda &amp;&amp; bool == True  &amp;&amp; ((elem (Porta,(x-1,y)) (desconstroiMapa mapa)) || not(elem (Porta,(x-1,y)) (desconstroiMapa mapa))) = (Jogo (andaCaixa j AndarEsquerda) (Jogador (x-1,yqO) Oeste bool))
                                 | mov == AndarDireita  &amp;&amp; bool == True  &amp;&amp; ((elem (Porta,(x+1,y)) (desconstroiMapa mapa)) || not(elem (Porta,(x+1,y)) (desconstroiMapa mapa))) = (Jogo (andaCaixa j AndarDireita)  (Jogador (x+1,yqE) Este bool))
                                 | mov == AndarEsquerda &amp;&amp; bool == False &amp;&amp; ((elem (Porta,(x-1,y)) (desconstroiMapa mapa)) || not(elem (Porta,(x-1,y)) (desconstroiMapa mapa))) = (Jogo mapa (Jogador (x-1,yqO) Oeste bool))
                                 | mov == AndarDireita  &amp;&amp; bool == False &amp;&amp; ((elem (Porta,(x+1,y)) (desconstroiMapa mapa)) || not(elem (Porta,(x+1,y)) (desconstroiMapa mapa))) = (Jogo mapa (Jogador (x+1,yqE) Este  bool))
                              where yqE = yDoChao (x+1,y) (desconstroiMapa mapa)
                                    yqO = yDoChao (x-1,y) (desconstroiMapa mapa)
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code><a href="Tarefa4_2021li1g043.html#v:andaJogador" title="Tarefa4_2021li1g043">andaJogador</a></code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>andaJogador (Jogo [[Vazio, Vazio, Vazio, Caixa], [Vazio, Vazio, Caixa, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (3,1) Oeste True)) = (Jogo [[Vazio, Vazio, Caixa, Vazio], [Vazio, Vazio, Vazio, Vazio],[Bloco, Bloco, Bloco, Bloco]] (Jogador (2,1) Oeste True))
</code></strong></pre></div></div><div class="top"><p class="src"><a id="v:yDoChao" class="def">yDoChao</a> :: <a href="LI12122.html#t:Coordenadas" title="LI12122">Coordenadas</a> -&gt; [(<a href="LI12122.html#t:Peca" title="LI12122">Peca</a>, <a href="LI12122.html#t:Coordenadas" title="LI12122">Coordenadas</a>)] -&gt; Int <a href="#v:yDoChao" class="selflink">#</a></p><div class="doc"><h2>Defini&#231;&#227;o Geral</h2><p>Obt&#234;m o y do chao.</p><h2>Defini&#231;&#227;o mais espec&#237;fica</h2><p>A fun&#231;&#227;o <code>ydoChao</code> vai correr a lista toda de pe&#231;as at&#233; encontrar uma que respeita as condi&#231;&#245;es apresentadas e, nesse caso d&#225; a ordenada a cima desta mesma pe&#231;a.</p><h2>Caso de paragem</h2><p>Esta fun&#231;&#227;o n&#227;o tem caso de paragem porque &#233; auxiliar de v&#225;rias fun&#231;&#245;es j&#225; apresentadas e como nunca &#233; usada independentemente, o seu caso de paragem est&#225; relacionado com a fun&#231;&#227;o onde &#233; implementada.</p><pre>yDoChao :: Coordenadas -&gt; [(Peca,Coordenadas)] -&gt; Int
yDoChao (x,y) ((c,(xs,ys)):t) 
               | ys &gt;= y &amp;&amp; xs == x &amp;&amp; (c == Bloco || c == Caixa) = (ys-1)
               | otherwise = yDoChao (x,y) t
</pre><h2>Exemplo de utiliza&#231;&#227;o da fun&#231;&#227;o <code>ydoChao</code>:</h2><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>ydoChao (1,0) = [(Vazio,(0,0)), (Vazi,(1,0)), (Vazio,(2,0)), (Vazio,(3,0)), (Vazio,(0,1)),(Vazio,(1,1)), (Bloco,(2,1)), (Vazio,(3,1)), (Vazio,(0,2)), (Vazio,(1,2)), (Bloco,(2,2)), (Vazio,(2,3)), (Bloco,(0,3)), (Bloco,(1,3)), (Bloco,(2,3)), (Bloco,(3,3))] = 2
</code></strong></pre></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>